"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const qs_1 = require("qs");
const Validator_1 = __importDefault(require("./Validator"));
const util_1 = require("../util");
const validator = Validator_1.default;
const UNPROCESSABLE_ENTITY = 422;
class BaseService {
    constructor(endpoint, parameters = {}) {
        this.endpoint = endpoint;
        this.parameters = parameters;
        this.errors = Validator_1.default;
    }
    get $http() {
        return BaseService.$http;
    }
    get $errorProperty() {
        return BaseService.$errorProperty;
    }
    get $resetParameter() {
        return BaseService.$resetParameter;
    }
    get $parsedQs() {
        return BaseService.$parsedQs;
    }
    all() {
        return this.submit('get');
    }
    find(id) {
        return this.submit('get', id);
    }
    post(payload, config) {
        return this.submit('post', '', payload, config);
    }
    store(payload, config) {
        return this.post(payload, config);
    }
    put(id, payload, config) {
        const parameter = id && !(0, lodash_1.isObject)(id) ? `/${id}` : '';
        const body = (0, lodash_1.isObject)(id) ? id : payload;
        const requestType = (0, util_1.hasFiles)(body) ? 'post' : 'put';
        if ((0, util_1.hasFiles)(body))
            Object.assign(body, { _method: 'put' });
        return this.submit(requestType, parameter, body, config);
    }
    patch(id, payload, config) {
        const parameter = id && !(0, lodash_1.isObject)(id) ? `/${id}` : '';
        const body = (0, lodash_1.isObject)(id) ? id : payload;
        return this.submit('patch', parameter, body, config);
    }
    update(id, payload) {
        return this.patch(id, payload);
    }
    delete(id) {
        return this.submit('delete', `/${id}`);
    }
    remove(id) {
        return this.delete(id);
    }
    $submit(method, param, form, config) {
        this.beforeSubmit();
        return new Promise((resolve, reject) => {
            const formData = (0, util_1.hasFiles)(form) ? (0, util_1.objectToFormData)(form) : form;
            const endpointPath = param ? `/${this.endpoint}/${param}` : `/${this.endpoint}`;
            const endpoint = endpointPath.replace(/\/\//g, '/');
            const url = this.__getParameterString(endpoint);
            const axiosConfig = { url, data: formData, method, ...config };
            this.$http(axiosConfig)
                .then((response) => {
                this.onSuccess();
                resolve(response);
            })
                .catch((error) => {
                this.errors.processing = false;
                validator.processing = false;
                const { response } = error;
                if (response && response.status === UNPROCESSABLE_ENTITY) {
                    const { data } = response;
                    const validationErrors = {};
                    Object.assign(validationErrors, data[this.$errorProperty]);
                    this.onFail(validationErrors);
                }
                reject(error);
            });
            if (this.$resetParameter)
                this.removeParameters();
        });
    }
    submit(method, url, form, config) {
        return new Promise((resolve, reject) => {
            this.$submit(method, url, form, config)
                .then(({ data }) => resolve(data))
                .catch((err) => reject(err));
        });
    }
    __getParameterString(url) {
        const query = (0, qs_1.stringify)(this.parameters, {
            encode: true,
            skipNulls: true,
            addQueryPrefix: true,
            encodeValuesOnly: true,
            strictNullHandling: true,
        });
        return `${url}${query}`;
    }
    setParameters(parameters) {
        Object.keys(parameters).forEach((key) => {
            this.parameters[key] = parameters[key];
        });
        return this;
    }
    setParameter(parameter, value) {
        if (!value) {
            const options = Object.assign({}, this.$parsedQs, {
                comma: true,
                allowDots: true,
                ignoreQueryPrefix: true,
            });
            const params = (0, qs_1.parse)(parameter, options);
            return this.setParameters(params);
        }
        this.parameters[parameter] = value;
        return this;
    }
    removeParameters(parameters = []) {
        if (!parameters || !parameters.length) {
            this.parameters = {};
        }
        else if (Array.isArray(parameters)) {
            for (const parameter of parameters)
                delete this.parameters[parameter];
        }
        return this;
    }
    removeParameter(parameter) {
        delete this.parameters[parameter];
        return this;
    }
    onFail(errors) {
        this.errors.fill(errors);
        validator.fill(errors);
    }
    beforeSubmit() {
        if (!this.$http)
            throw new Error('Vue Axios Http, No http library provided.');
        this.errors.flush();
        this.errors.processing = true;
        this.errors.successful = false;
        validator.flush();
        validator.processing = true;
        validator.successful = false;
    }
    onSuccess() {
        this.errors.processing = false;
        this.errors.successful = true;
        validator.processing = false;
        validator.successful = true;
    }
}
BaseService.$errorProperty = 'errors';
BaseService.$resetParameter = false;
BaseService.$parsedQs = {
    comma: true,
    allowDots: true,
    ignoreQueryPrefix: true,
};
exports.default = BaseService;
