"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const util_1 = require("../util");
class Validator {
    constructor(errors = {}) {
        this.errors = errors;
        this.processing = false;
        this.successful = false;
    }
    add(field, message, forceUpdate) {
        if (this.missed(field))
            this.errors[field] = [];
        if (!this.errors[field].includes(message))
            this.errors[field].unshift(message);
        if (forceUpdate) {
            this.errors[field] = [];
            this.errors[field].push(message);
        }
    }
    has(field) {
        const fields = this.fields(field);
        return (0, util_1.is)(Object.keys(this.errors), fields);
    }
    first(field) {
        if (Array.isArray(field)) {
            const fields = this.fields(field);
            let fd = '';
            for (const f of fields) {
                if ((0, lodash_1.has)(this.errors, f)) {
                    fd = f;
                    break;
                }
            }
            return this.first(fd);
        }
        else {
            const value = this.get(field);
            if (Array.isArray(value))
                return value[0];
            return value;
        }
    }
    firstBy(obj, field) {
        let value;
        if (!field) {
            value = obj[Object.keys(obj)[0]];
        }
        else {
            value = obj[field];
        }
        if (Array.isArray(value))
            value = value[0];
        return value;
    }
    missed(field) {
        return !this.has(field);
    }
    nullState(field) {
        return this.has(field) ? this.missed(field) : null;
    }
    any(field = [], returnObject) {
        const fields = this.fields(field);
        if (returnObject) {
            const errors = {};
            if (!fields.length)
                return {};
            for (const f of fields) {
                const val = this.get(f);
                if (!val.length)
                    continue;
                errors[f] = val;
            }
            return errors;
        }
        if (!fields.length)
            return Object.keys(this.errors).length > 0;
        const errors = {};
        fields.forEach((key) => (errors[key] = this.get(key)));
        return Object.keys(errors).length > 0;
    }
    get(field) {
        return (0, lodash_1.get)(this.errors, field, []);
    }
    all() {
        return this.errors;
    }
    count() {
        return Object.keys(this.errors).length;
    }
    fill(errors) {
        this.errors = errors;
    }
    flush() {
        this.fill({});
    }
    clear(field) {
        if (!field)
            return this.flush();
        const errors = (0, lodash_1.omit)((0, lodash_1.cloneDeep)(this.errors), this.fields(field));
        this.fill(errors);
    }
    isValid() {
        return !this.any();
    }
    onKeydown(event, prefix) {
        const { name } = event.target;
        if (!name)
            return;
        const names = prefix ? [name, `${prefix}.${name}`] : [name];
        this.clear(names);
    }
    fields(field) {
        const fields = [];
        if (Array.isArray(field)) {
            for (const f of field) {
                fields.push((0, util_1.toCamelCase)(f), (0, util_1.toSnakeCase)(f));
            }
        }
        else {
            fields.push((0, util_1.toCamelCase)(field), (0, util_1.toSnakeCase)(field));
        }
        return [...new Set(fields)].filter(Boolean);
    }
}
exports.default = new Validator();
